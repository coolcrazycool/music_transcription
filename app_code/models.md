# Поля и функции классов

## Класс "Notes":
### переменные:
  * inputData - массив, каждый элемент которого - массив из 2 элементов, а именно:
    * номер ноты (-1, если ноты нет) 
    * количество долей, которое она длится(длительноть 1 доли - *segment_time*)
  * filterData - отфильтрованный входной массив, из которого исключили короткие паузы и ноты(см константы NOIZE_FILTER_TIME и NOIZE_FILTER_PAUSE)
  * data - массив, каждый элемент которого - массив из 2 элементов, а именно:
    * номер ноты (-1, если ноты нет) 
    * её длительность: целая, половинка, четверть...
       *(Кодировка: MINNOTE, по дефалту = 16, = 1, это нота*2 = 2, т.е. восьмая, 4 - четверть и тд...(степени 2)*
  * freqList - содержит только длительности нот
  * notes - сожержит ноты abjad опр длительности и высоты, т.е. конечный массив
  
  
## Класс "Melody":
### переменные:
  * path - путь до файла для распознавания
  * data - массив, каждый элемент которого - массив из 2 элементов, а именно:
    * номер ноты (-1, если ноты нет) 
    * количество долей, которое она длится(длительноть 1 доли - *segment_time*)
  
## константы:
  * MIN_NOTE = 16  # Минимальная длительность будет приравниваться к этому числу. В данном случае, константа = 16,
 т.е. миннимальная нота при записи будет шестнадцатая, относительно нее все будет считаться.
 Для простановки других мин нот используйте степени 2. Восьмая - 8, тридцатьвторая - 32 и тд...
 функция abj_duration и strange_rythm и long_note сделано под 16! Надо справить проверку длительностей норм и нет
 * NOIZE_FILTER_TIME = 0 -ноты, которые длятся такое количество долей и меньше затираются(прибаляются к предыдущей ноте)
  * NOIZE_FILTER_PAUSE = 4 паузы, длящиеся такое количество долей прибавляются у предыдущей ноте
  * BASE_NOTE = 60 из-за разных кодировок приходится сдвигать номер нот. В abjad 0 нота - до первой октавы, из-за этого приходится отнимать 60, чтобы из системы прежних кодировок перейти к кодировке  abjad
  
              
